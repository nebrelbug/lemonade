#pragma config(Motor,  port1,           BackRight,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           BackLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           RightArmLift,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           LeftArmLift,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           LeftConeLift,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           RightConeLift, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           ClawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           FrontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           FrontRight,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//****-----****

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//Variables ( I define these varaibles up here just for asthetics; to know what the variables I'm using
int direction, speed, speed1, speed2, speed3;
// Speed     - for when the speed variable can be applie dto all motors and get the desired result
// speed1    - for when the sides of the robot are supposed to go different directions
// speed2    - accompanies speed1 in its job
// speed3    - Currently has no purpose
// Direction - A variable to help calculate whether the motors should spin forwards or backwards
//Remember that function have to be defined out her and not in the task main!

//****-----****

void ClawMove(int direction, int speed)
{
	//So the way I understand this code to work is that it takes in the speed; which can be any value from -127-127,
  //but specifically fo this code I would only use 0-127 and holds that for a little.
  //Then it takes in the direction var and makes it equal to the direction that was passed in to the function;
  //wich will be either a 1 or 2, and  * '-2' to make it either a '-2' or a '4'; which when added to the 3 make a '1' or a '-1'.
  // Then the speed get multiplied by direction and becomes the speed for the robot and based on whether the direction is '-1' or '1'
  //, the speed also gets to control the direction of the robot, all in one variable..
	direction = (direction*-2) + 3;
	motor[ClawMotor] = speed*direction;
	wait1Msec(10);
	motor[ClawMotor] = 0;
}

//****-----****

void MoveBot(int direction, int speed)// the variable is to help switch between the functionality of this function for normal driving and autonomous
{

		motor[FrontLeft] = vexRT[Ch3];
		motor[BackLeft] = vexRT[Ch3];
		motor[FrontRight] = vexRT[Ch2];
		motor[BackRight] = vexRT[Ch2];

}

//****-----****

void ArmMove(int direction, int speed)
{
	direction = (direction*-2) + 3;
	motor[LeftArmLift] = speed*direction;
	motor[RightArmLift] = speed*direction;
	wait10Msec(10);
	motor[LeftArmLift] = 0;
	motor[RightArmLift] = 0;
}

//****-----****

//The commneted section of code bellow was supposed to be a function that would allow for variable speeds and versitility, but just
//using the motors connected to the joysticks dirrectly is way better.
//void RobotGroundMove(int direction, int speed)// Don't use this at the moment, this is jibergaber right now
// Haven't yet implemented this awsome, but incomplete functionality,
//don't mind the first if statement
//{
	// I will use if statements here for now because, that way I think I can implement the whole
  //control structure of how to decide whether the drive wants to dirve forward, backward, left or right.
//	if (direction == 3)
		// If the value 3 is being recieved (if I typed that correctly, heh), then the
		//motors on the left side will be set to full forward power and the right side motors will be set to full backwards power
//		motor[FrontLeft]  =  127;
//		motor[BackLeft]   = 127;
//		motor[FrontRight] = -127;
//		motor[BackRight]  = -127;
//	}
//	direction = (direction*-2) + 3;
//	motor[FrontLeft] = speed*direction;
//	motor[BackLeft] = speed*direction;
//	wait1Msec(10);
//}


//****-----****

task main()
{
	//void
	while (true)// Loop that all code that needs to run throught the game has to be in (The main while loop).
	{
		if (vexRT[Btn8U] == 1)// Moves the arm up
		{
			ArmMove(2, 60);//The motors are arranged onthe robot in such a way that the direction has to be backwards
		}
		if (vexRT[Btn8R] == 1)// Moves the arm down
		{
			ArmMove(1, 60);
		}
		if (vexRT[Btn6U] == 1)// Opens the claw
		{
			ClawMove(2, 60);//The motors are arranged onthe robot in such a way that the direction has to be backwards
		}
		if (vexRT[Btn6D] == 1)//Closes the claw
		{
			ClawMove(2, 60);
		}
		if (vexRT(Ch3) > 0 && vexRT(Ch2) < 0)
		{
			MoveBot(2, 100)
			//speed1 = veXRT(Ch3);
			//s
		}

		//****-----****

		//Autonomous
		if (vexRT[Btn8L] == 1)//This is the autonomous
		{
			motor[FrontLeft] = 127;
			motor[BackLeft] = 127;
			motor[FrontRight] = 127;
			motor[BackRight] = 127;
			//wait1Msec(500);
			motor[FrontLeft] = 0;
			motor[BackLeft] = 0;
			motor[FrontRight] = 0;
			motor[BackRight] = 0;
			motor[BackRight] = 127;
			//wait1Msec(500);
			//motor[ClawMotor] = 0;
			//motor[LeftArmLift] = 127;
			//motor[RightArmLift] = 127;
			//wait1Msec(1000);
			//motor[LeftArmLift] = 127;
			//motor[RightArmLift] = 127;

			//Below is just idea code for now

      //****-----****

			// My plan for the autonomous is to get the robot to drive to the section of mobile bases and cones that is closest to the starting spot
		  // then get sevral cones stacked on top of eachother and stack that on a mobile base, and get the base past the two bars for the most point
		  //quick.
			// So this code is to make the Robot drive up to the set of cones that it will be pointed towards at the start of the autonomous
			//MoveBot(2, 100);//This uses the 'MoveBot' function to and drives the robot based on preprogramed values passed to the function
			//wait1Msec(100);//This I undertand, is what makes it possible to make the robot do some task for a specific amount of time.
			//MoveBot(2, 0);//This uses the 'MoveBot' function to stop the robot ground movement; by passing the value 0 which goes to the else
			// and tells the robot the direction which doesn't matter since the robot will stop, then sets the power to 0.
			//ClawMove(2, 80);// This code block opens tha claw for a specifc amount of time
			//wait1Msec(100);
			//ClawMove(2, 0);
		}
	}// End of loop that all code should be in (The main while loop).
}
